<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLB Character Generator PWA</title>
    <link rel="manifest" href="data:application/manifest+json,{
        'name': 'GLB Generator',
        'short_name': 'GLBGen',
        'start_url': '.',
        'display': 'standalone',
        'background_color': '#ffffff',
        'theme_color': '#000000'
    }">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { font-family: Arial; margin: 20px; }
        #viewer { width: 100%; height: 400px; border: 1px solid #ccc; }
        button { margin: 10px; padding: 10px; }
        #status { color: green; }
        #error { color: red; }
    </style>
</head>
<body>
    <h1>GLB Character Generator (PWA)</h1>
    <p>Click to generate a simple rigged & animated male explorer geologist character in GLB.</p>
    <button onclick="generateAndExport()">Generate & Download GLB</button>
    <div id="viewer"></div>
    <p id="status"></p>
    <p id="error"></p>
    <a id="downloadLink" style="display:none;">Download GLB</a>

    <script>
        let scene, camera, renderer, controls, mixer;

        function initViewer() {
            const container = document.getElementById('viewer');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd);
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 1, 1);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            camera.position.set(0, 1, 3);
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (mixer) mixer.update(0.01);
            controls.update();
            renderer.render(scene, camera);
        }

        function generateAndExport() {
            initViewer();
            document.getElementById('status').textContent = 'Generating model...';
            document.getElementById('error').textContent = '';

            try {
                // Create bones for skeleton (humanoid)
                const bones = [];
                const rootBone = new THREE.Bone();
                bones.push(rootBone);

                // Spine and head
                const spineBone = new THREE.Bone();
                spineBone.position.y = 1;
                rootBone.add(spineBone);
                bones.push(spineBone);

                const headBone = new THREE.Bone();
                headBone.position.y = 0.5;
                spineBone.add(headBone);
                bones.push(headBone);

                // Arms
                const leftArmBone = new THREE.Bone();
                leftArmBone.position.set(-0.3, 0.4, 0);
                spineBone.add(leftArmBone);
                bones.push(leftArmBone);

                const leftForearmBone = new THREE.Bone();
                leftForearmBone.position.y = -0.4;
                leftArmBone.add(leftForearmBone);
                bones.push(leftForearmBone);

                const rightArmBone = new THREE.Bone();
                rightArmBone.position.set(0.3, 0.4, 0);
                spineBone.add(rightArmBone);
                bones.push(rightArmBone);

                const rightForearmBone = new THREE.Bone();
                rightForearmBone.position.y = -0.4;
                rightArmBone.add(rightForearmBone);
                bones.push(rightForearmBone);

                // Legs
                const leftLegBone = new THREE.Bone();
                leftLegBone.position.set(-0.2, -0.5, 0);
                rootBone.add(leftLegBone);
                bones.push(leftLegBone);

                const leftCalfBone = new THREE.Bone();
                leftCalfBone.position.y = -0.5;
                leftLegBone.add(leftCalfBone);
                bones.push(leftCalfBone);

                const rightLegBone = new THREE.Bone();
                rightLegBone.position.set(0.2, -0.5, 0);
                rootBone.add(rightLegBone);
                bones.push(rightLegBone);

                const rightCalfBone = new THREE.Bone();
                rightCalfBone.position.y = -0.5;
                rightLegBone.add(rightCalfBone);
                bones.push(rightCalfBone);

                const skeleton = new THREE.Skeleton(bones);

                // Create geometry (simple body parts)
                const group = new THREE.Group();

                // Torso
                const torsoGeo = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
                const torsoMat = new THREE.MeshBasicMaterial({ color: 0x8B4513 }); // Brown clothes
                const torso = new THREE.SkinnedMesh(torsoGeo, torsoMat);
                torso.bind(skeleton);
                group.add(torso);

                // Head
                const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
                const headMat = new THREE.MeshBasicMaterial({ color: 0xFFDAB9 }); // Skin tone
                const head = new THREE.SkinnedMesh(headGeo, headMat);
                head.position.y = 1.25;
                head.bind(skeleton);
                group.add(head);

                // Hat
                const hatGeo = new THREE.ConeGeometry(0.3, 0.2, 8);
                const hatMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 }); // Yellow hat
                const hat = new THREE.Mesh(hatGeo, hatMat);
                hat.position.y = 1.5;
                group.add(hat);

                // Arms (simple cylinders)
                const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
                const leftArm = new THREE.SkinnedMesh(armGeo, torsoMat);
                leftArm.position.set(-0.3, 0.9, 0);
                leftArm.rotation.z = Math.PI / 2;
                leftArm.bind(skeleton);
                group.add(leftArm);

                const rightArm = leftArm.clone();
                rightArm.position.x = 0.3;
                group.add(rightArm);

                // Legs
                const legGeo = new THREE.CylinderGeometry(0.15, 0.15, 1, 8);
                const legMat = new THREE.MeshBasicMaterial({ color: 0x654321 }); // Dark boots/pants
                const leftLeg = new THREE.SkinnedMesh(legGeo, legMat);
                leftLeg.position.set(-0.2, 0, 0);
                leftLeg.bind(skeleton);
                group.add(leftLeg);

                const rightLeg = leftLeg.clone();
                rightLeg.position.x = 0.2;
                group.add(rightLeg);

                // Backpack (box on back)
                const backpackGeo = new THREE.BoxGeometry(0.4, 0.6, 0.2);
                const backpackMat = new THREE.MeshBasicMaterial({ color: 0x556B2F });
                const backpack = new THREE.Mesh(backpackGeo, backpackMat);
                backpack.position.set(0, 1, -0.2);
                group.add(backpack);

                // Pickaxe (attached to right hand)
                const pickaxeHandle = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
                const pickaxeMat = new THREE.MeshBasicMaterial({ color: 0xA9A9A9 }); // Metallic
                const pickaxe = new THREE.Mesh(pickaxeHandle, pickaxeMat);
                pickaxe.position.set(0.3, 0.5, 0);
                pickaxe.rotation.x = Math.PI / 4;
                group.add(pickaxe);

                const pickHeadGeo = new THREE.BoxGeometry(0.3, 0.1, 0.1);
                const pickHead = new THREE.Mesh(pickHeadGeo, pickaxeMat);
                pickHead.position.y = -0.5;
                pickaxe.add(pickHead);

                // Add to scene
                scene.add(group);

                // Create animations
                mixer = new THREE.AnimationMixer(group);

                // Idle animation (simple sway)
                const idleClip = new THREE.AnimationClip('Idle', -1, [
                    new THREE.VectorKeyframeTrack('.position', [0, 1, 2], [0, 0, 0, 0, 0.05, 0, 0, 0, 0])
                ]);
                const idleAction = mixer.clipAction(idleClip);
                idleAction.play();

                // Walk animation (leg/arm swing)
                const walkTimes = [0, 0.5, 1];
                const walkValuesLeg = [0, Math.PI/4, 0];
                const walkValuesArm = [0, -Math.PI/4, 0];
                const walkClip = new THREE.AnimationClip('Walk', -1, [
                    new THREE.NumberKeyframeTrack('bones[' + bones.indexOf(leftLegBone) + '].rotation[x]', walkTimes, walkValuesLeg),
                    new THREE.NumberKeyframeTrack('bones[' + bones.indexOf(rightLegBone) + '].rotation[x]', walkTimes, walkValuesLeg.map(v => -v)),
                    new THREE.NumberKeyframeTrack('bones[' + bones.indexOf(leftArmBone) + '].rotation[x]', walkTimes, walkValuesArm.map(v => -v)),
                    new THREE.NumberKeyframeTrack('bones[' + bones.indexOf(rightArmBone) + '].rotation[x]', walkTimes, walkValuesArm)
                ]);
                // mixer.clipAction(walkClip).play(); // Uncomment to test

                // Pick action (swing arm with pickaxe)
                const pickTimes = [0, 0.3, 0.6];
                const pickValues = [0, Math.PI/2, 0];
                const pickClip = new THREE.AnimationClip('Pick', -1, [
                    new THREE.NumberKeyframeTrack('bones[' + bones.indexOf(rightArmBone) + '].rotation[z]', pickTimes, pickValues)
                ]);
                // mixer.clipAction(pickClip).play(); // Uncomment to test

                // Embed animations in the group for export
                group.animations = [idleClip, walkClip, pickClip];

                // Fit camera
                const box = new THREE.Box3().setFromObject(group);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                camera.position.z = Math.max(size.x, size.y, size.z) * 1.5;
                controls.target = center;

                document.getElementById('status').textContent = 'Model generated! Exporting to GLB...';

                // Export to GLB
                const exporter = new THREE.GLTFExporter();
                exporter.parse(scene, (glb) => {
                    const blob = new Blob([glb], { type: 'model/gltf-binary' });
                    const url = URL.createObjectURL(blob);
                    const link = document.getElementById('downloadLink');
                    link.href = url;
                    link.download = 'explorer_geologist.glb';
                    link.textContent = 'Download GLB File';
                    link.style.display = 'block';
                    document.getElementById('status').textContent = 'Done! Download below.';
                }, (error) => {
                    document.getElementById('error').textContent = 'Export error: ' + error;
                }, { binary: true, animations: group.animations });

            } catch (error) {
                document.getElementById('error').textContent = 'Error: ' + error.message;
            }
        }

        // Resize handler
        window.addEventListener('resize', () => {
            const container = document.getElementById('viewer');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    </script>
</body>
</html>