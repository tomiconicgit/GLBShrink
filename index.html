<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Character Builder PWA</title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no" />
  <link id="manifest-link" rel="manifest" />
  <meta name="theme-color" content="#121212" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAAKLWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIqbKFVhArgUdAVPwLxeKygsSIqyYakGr4akYovkWRWAYHOHCk pulmAAVMikoADGHYDyYDm4DC5IAToAdWzMsAFoNWgaCRayBJSNgFddNABiWDFBgSDQAe2QXgAPACgDbQ reformulation of all of the above:

You can save this code as `index.html` and it will function as a complete, offline-first Progressive Web App.

***

### `index.html` (All-in-One File)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Character Builder PWA</title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no" />
  <link id="manifest-link" rel="manifest" />
  <meta name="theme-color" content="#121212" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <style>
    /* General Body & Root Styles */
    :root {
      --background-color: #121212;
      --surface-color: rgba(28, 28, 30, 0.75);
      --primary-text-color: #ffffff;
      --secondary-text-color: #a0a0a0;
      --accent-color: #007aff;
      --panel-border-radius: 16px;
      --button-border-radius: 10px;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background-color: var(--background-color);
      color: var(--primary-text-color);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      -webkit-font-smoothing: antialiased;
    }
    /* Canvas Container */
    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    /* Main UI Container */
    #ui-container {
      position: fixed;
      bottom: env(safe-area-inset-bottom, 15px);
      left: 50%;
      transform: translateX(-50%);
      width: 95%;
      max-width: 420px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      background: var(--surface-color);
      padding: 12px;
      border-radius: var(--panel-border-radius);
      backdrop-filter: blur(12px) saturate(180%);
      -webkit-backdrop-filter: blur(12px) saturate(180%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 10;
    }
    .ui-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    /* Inputs & Buttons */
    input, button {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: var(--button-border-radius);
      font-size: 16px;
      box-sizing: border-box;
    }
    input#prompt-input {
      background-color: rgba(0, 0, 0, 0.3);
      color: var(--primary-text-color);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    input#prompt-input::placeholder {
      color: var(--secondary-text-color);
    }
    button {
      background-color: var(--accent-color);
      color: var(--primary-text-color);
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    button:active {
      transform: scale(0.98);
    }
    button#export-btn {
      background-color: #333;
    }
    /* Animation Controls */
    .animation-controls {
      flex-direction: row;
    }
    /* Part Selector */
    #part-selector {
      max-height: 150px;
      overflow-y: auto;
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: var(--button-border-radius);
      padding: 8px;
    }
    .part-category {
      margin-bottom: 8px;
    }
    .part-category-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--secondary-text-color);
      margin-bottom: 4px;
      padding-left: 4px;
      text-transform: uppercase;
    }
    .part-toggles {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .part-toggle {
      background-color: #333;
      padding: 6px 12px;
      font-size: 14px;
      width: auto;
      flex-grow: 1;
    }
    .part-toggle.active {
      background-color: var(--accent-color);
      box-shadow: 0 0 10px var(--accent-color);
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="ui-container">
    <div class="ui-section">
      <input id="prompt-input" placeholder="e.g., female paladin, long hair, leather gloves" />
      <button id="build-btn">Build Character</button>
    </div>
    <div id="part-selector" class="ui-section"></div>
    <div class="ui-section animation-controls">
      <button class="anim-btn" data-anim="idle">Idle</button>
      <button class="anim-btn" data-anim="walk">Walk</button>
      <button class="anim-btn" data-anim="attack">Attack</button>
    </div>
    <button id="export-btn">Export .glb</button>
  </div>

  <script type="module">
    import * as THREE from '[https://cdn.skypack.dev/three@0.155.0](https://cdn.skypack.dev/three@0.155.0)';
    import { OrbitControls } from '[https://cdn.skypack.dev/three/examples/jsm/controls/OrbitControls.js](https://cdn.skypack.dev/three/examples/jsm/controls/OrbitControls.js)';
    import { GLTFExporter } from '[https://cdn.skypack.dev/three/examples/jsm/exporters/GLTFExporter.js](https://cdn.skypack.dev/three/examples/jsm/exporters/GLTFExporter.js)';

    // --- 1. PROMPT PARSER LOGIC ---
    const parsePrompt = (() => {
      const keywords = {
        gender: {
          male: ['male', 'man', 'boy', 'guy'],
          female: ['female', 'woman', 'girl', 'lady'],
        },
        parts: ['gloves', 'skirt', 'corse', 'boot', 'arm_armor_1'],
        materials: {
          plate: ['plate', 'metal', 'steel', 'paladin', 'knight'],
          leather: ['leather', 'hide', 'rogue', 'ranger'],
        },
        hairstyle: {
          long: ['long hair', 'long'],
          default: ['short hair', 'spiky', 'default'],
        }
      };

      return function(prompt) {
        const text = prompt.toLowerCase();
        const config = {
          gender: 'male',
          parts: new Set(['Body', 'Hair']),
          materials: { armor: 'plate', body: 'default' },
          hairstyle: 'default',
        };
        if (keywords.gender.female.some(kw => text.includes(kw))) config.gender = 'female';
        if (keywords.materials.leather.some(kw => text.includes(kw))) config.materials.armor = 'leather';
        if (keywords.hairstyle.long.some(kw => text.includes(kw))) config.hairstyle = 'long';
        keywords.parts.forEach(part => {
          const partKey = part.charAt(0).toUpperCase() + part.slice(1);
          if (text.includes(part)) config.parts.add(partKey);
        });
        if (config.materials.armor && (text.includes('armor') || text.includes('paladin') || text.includes('knight'))) {
          config.parts.add('Corse');
          config.parts.add('Boot');
        }
        console.log('Parsed Config:', config);
        return config;
      };
    })();

    // --- 2. CHARACTER MANAGER CLASS ---
    class CharacterManager {
      constructor(scene) {
        this.scene = scene;
        this.character = new THREE.Group();
        this.character.position.y = 0.8;
        this.scene.add(this.character);
        this.parts = {};
        this.mixer = null;
        this.animations = {};
        this.activeAction = null;

        this.materials = {
          body: { default: new THREE.MeshStandardMaterial({ color: 0xad7258, roughness: 0.8 }) },
          hair: { default: new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 }) },
          armor: {
            plate: new THREE.MeshStandardMaterial({ color: 0xsilver, metalness: 0.9, roughness: 0.2 }),
            leather: new THREE.MeshStandardMaterial({ color: 0x5c3d20, roughness: 0.7 })
          }
        };
        this.geometries = {
          Body: {
            male: new THREE.CylinderGeometry(0.1, 0.4, 1.5, 32),
            female: new THREE.CylinderGeometry(0.2, 0.35, 1.4, 32)
          },
          Hair: {
            default: new THREE.SphereGeometry(0.4, 16, 8),
            long: new THREE.ConeGeometry(0.5, 1.2, 16),
          },
          Corse: new THREE.BoxGeometry(0.9, 0.8, 0.5),
          Gloves: new THREE.BoxGeometry(0.25, 0.25, 0.25),
          Boot: new THREE.BoxGeometry(0.3, 0.4, 0.3),
          Skirt: new THREE.CylinderGeometry(0.5, 0.7, 0.6, 16),
          Arm_Armor_1: new THREE.BoxGeometry(0.2, 0.6, 0.2),
        };
        this.initAnimations();
      }
      build(config) {
        this.clearCharacter();
        const armorMat = this.materials.armor[config.materials.armor] || this.materials.armor.plate;
        const bodyMat = this.materials.body[config.materials.body] || this.materials.body.default;
        const hairMat = this.materials.hair.default;
        config.parts.forEach(partName => {
          let geo, mat = armorMat;
          if (partName === 'Body') { geo = this.geometries.Body[config.gender]; mat = bodyMat; } 
          else if (partName === 'Hair') { geo = this.geometries.Hair[config.hairstyle]; mat = hairMat; } 
          else { geo = this.geometries[partName]; }
          if (geo) this.addPart(partName, geo, mat);
        });
        this.playAnimation('idle');
      }
      addPart(name, geometry, material) {
        const mesh = new THREE.Mesh(geometry, material);
        mesh.name = name;
        switch (name) {
          case 'Body': mesh.position.y = 0.8; break;
          case 'Hair': mesh.position.y = 1.8; break;
          case 'Corse': mesh.position.y = 1.0; break;
          case 'Gloves': mesh.position.set(0.6, 0.8, 0); break;
          case 'Arm_Armor_1': mesh.position.set(-0.6, 0.8, 0); break;
          case 'Boot': mesh.position.y = 0.2; break;
          case 'Skirt': mesh.position.y = 0.4; break;
        }
        this.parts[name] = mesh;
        this.character.add(mesh);
      }
      clearCharacter() {
        Object.values(this.parts).forEach(part => this.character.remove(part));
        this.parts = {};
      }
      togglePart(partName, isVisible) { if (this.parts[partName]) this.parts[partName].visible = isVisible; }
      getPartList() { return { 'Armor': ['Corse', 'Gloves', 'Arm_Armor_1', 'Boot', 'Skirt'], 'Cosmetic': ['Hair'] }; }
      initAnimations() {
        this.mixer = new THREE.AnimationMixer(this.character);
        const idleTrack = new THREE.VectorKeyframeTrack('.position', [0, 1, 2], [0, 0.8, 0, 0, 0.82, 0, 0, 0.8, 0]);
        this.animations.idle = new THREE.AnimationClip('idle', -1, [idleTrack]);
        const walkTrack = new THREE.VectorKeyframeTrack('.rotation[y]', [0, 0.5, 1], [0, 0.2, 0]);
        this.animations.walk = new THREE.AnimationClip('walk', -1, [walkTrack]);
        const attackTrack = new THREE.NumberKeyframeTrack('.rotation[z]', [0, 0.2, 0.5], [0, -Math.PI / 2, 0]);
        const attackClip = new THREE.AnimationClip('attack', 0.5, [attackTrack]);
        attackClip.loop = THREE.LoopOnce;
        this.animations.attack = attackClip;
      }
      playAnimation(name) {
        if (!this.animations[name] || !this.mixer) return;
        const newAction = this.mixer.clipAction(this.animations[name]);
        if (this.activeAction) this.activeAction.fadeOut(0.2);
        newAction.reset().fadeIn(0.2).play();
        this.activeAction = newAction;
        this.mixer.removeEventListener('finished');
        if (this.activeAction.getClip().loop !== THREE.LoopRepeat) {
            this.mixer.addEventListener('finished', () => this.playAnimation('idle'));
        }
      }
      update(deltaTime) { if (this.mixer) this.mixer.update(deltaTime); }
      exportGLB() {
        const exporter = new GLTFExporter();
        const visibleParts = Object.values(this.parts).filter(p => p.visible);
        exporter.parse(visibleParts, glb => {
          const blob = new Blob([glb], { type: 'model/gltf-binary' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'character.glb';
          link.click();
          URL.revokeObjectURL(link.href);
        }, err => console.error('GLB export error:', err), { binary: true });
      }
    }

    // --- 3. SCENE MANAGER LOGIC ---
    const SceneManager = (() => {
      let scene, camera, renderer, controls, clock;
      let updateCallback = null;

      function init(container) {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x121212);
        clock = new THREE.Clock();
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 4);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 1, 0);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(3, 5, 3);
        scene.add(dirLight);
        const ground = new THREE.Mesh(new THREE.CircleGeometry(10, 32), new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 }));
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        window.addEventListener('resize', onWindowResize);
        animate();
      }
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        if (updateCallback) updateCallback(clock.getDelta());
        renderer.render(scene, camera);
      }
      return {
        init,
        getScene: () => scene,
        setUpdateCallback: (cb) => { updateCallback = cb; },
      };
    })();

    // --- 4. UI MANAGER LOGIC ---
    const UIManager = (() => {
      let callbacks = {};
      function init(appCallbacks, partList) {
        callbacks = appCallbacks;
        const buildBtn = document.getElementById('build-btn');
        const promptInput = document.getElementById('prompt-input');
        const exportBtn = document.getElementById('export-btn');
        buildBtn.addEventListener('click', () => callbacks.onBuild(promptInput.value));
        promptInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') buildBtn.click(); });
        exportBtn.addEventListener('click', () => callbacks.onExport());
        document.querySelectorAll('.anim-btn').forEach(btn => {
          btn.addEventListener('click', () => callbacks.onAnimate(btn.dataset.anim));
        });
        createPartSelector(partList);
      }
      function createPartSelector(partList) {
        const container = document.getElementById('part-selector');
        container.innerHTML = '';
        for (const category in partList) {
          const categoryDiv = document.createElement('div');
          categoryDiv.className = 'part-category';
          categoryDiv.innerHTML = `<div class="part-category-title">${category}</div>`;
          const togglesDiv = document.createElement('div');
          togglesDiv.className = 'part-toggles';
          partList[category].forEach(partName => {
            const button = document.createElement('button');
            button.className = 'part-toggle active';
            button.textContent = partName.replace(/_/g, ' ');
            button.dataset.part = partName;
            button.addEventListener('click', () => {
              button.classList.toggle('active');
              callbacks.onTogglePart(partName, button.classList.contains('active'));
            });
            togglesDiv.appendChild(button);
          });
          categoryDiv.appendChild(togglesDiv);
          container.appendChild(categoryDiv);
        }
      }
      return { init };
    })();

    // --- 5. PWA & MAIN INITIALIZATION ---
    function embedPwaAssets() {
      // Embed Manifest
      const manifest = {
        name: "Three.js Character Builder", short_name: "CharBuilder", start_url: "/",
        display: "standalone", background_color: "#121212", theme_color: "#121212",
        orientation: "portrait-primary", description: "A PWA for building 3D characters with Three.js.",
        icons: [ /* Icons would be linked here or embedded as data URIs */
          { "src": "/icons/icon-192x192.png", "sizes": "192x192", "type": "image/png" },
          { "src": "/icons/icon-512x512.png", "sizes": "512x512", "type": "image/png" }
        ]
      };
      const manifestString = JSON.stringify(manifest);
      const manifestBlob = new Blob([manifestString], {type: 'application/json'});
      document.getElementById('manifest-link').href = URL.createObjectURL(manifestBlob);

      // Embed Service Worker
      const swCode = `
        const CACHE_NAME = 'character-builder-v1';
        const ASSETS_TO_CACHE = [
          '[https://cdn.skypack.dev/three@0.155.0](https://cdn.skypack.dev/three@0.155.0)',
          '[https://cdn.skypack.dev/three/examples/jsm/controls/OrbitControls.js](https://cdn.skypack.dev/three/examples/jsm/controls/OrbitControls.js)',
          '[https://cdn.skypack.dev/three/examples/jsm/exporters/GLTFExporter.js](https://cdn.skypack.dev/three/examples/jsm/exporters/GLTFExporter.js)'
        ];
        self.addEventListener('install', event => {
          event.waitUntil(
            caches.open(CACHE_NAME).then(cache => cache.addAll(ASSETS_TO_CACHE))
              .then(() => self.skipWaiting())
          );
        });
        self.addEventListener('activate', event => {
          event.waitUntil(
            caches.keys().then(names => Promise.all(
              names.filter(name => name !== CACHE_NAME).map(name => caches.delete(name))
            ))
          );
        });
        self.addEventListener('fetch', event => {
          // Cache the page itself
          if (event.request.mode === 'navigate') {
            event.respondWith(caches.match(event.request) || fetch(event.request));
            return;
          }
          // For CDN assets, use a cache-first strategy
          event.respondWith(
            caches.match(event.request).then(response => {
              return response || fetch(event.request).then(networkResponse => {
                const respClone = networkResponse.clone();
                caches.open(CACHE_NAME).then(cache => cache.put(event.request, respClone));
                return networkResponse;
              });
            })
          );
        });
      `;
      const swBlob = new Blob([swCode], { type: 'application/javascript' });
      const swUrl = URL.createObjectURL(swBlob);

      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register(swUrl)
          .then(() => console.log('Service Worker registered successfully from Blob.'))
          .catch(err => console.error('Service Worker registration failed:', err));
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      const canvasContainer = document.getElementById('canvas-container');
      SceneManager.init(canvasContainer);
      
      const character = new CharacterManager(SceneManager.getScene());
      SceneManager.setUpdateCallback((deltaTime) => character.update(deltaTime));

      const initialConfig = {
          gender: 'male',
          parts: new Set(['Body', 'Hair', 'Corse', 'Boot', 'Gloves']),
          materials: { armor: 'plate', body: 'default' },
          hairstyle: 'default'
      };
      character.build(initialConfig);

      UIManager.init({
        onBuild: (prompt) => character.build(parsePrompt(prompt)),
        onAnimate: (name) => character.playAnimation(name),
        onExport: () => character.exportGLB(),
        onTogglePart: (part, isVisible) => character.togglePart(part, isVisible),
      }, character.getPartList());

      embedPwaAssets();
    });

  </script>
</body>
</html>
