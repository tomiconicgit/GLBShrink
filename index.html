<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Model Converter</title>
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#2c3e50">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%232c3e50'/%3E%3Ctext x='50' y='55' font-size='50' fill='%23ffffff' text-anchor='middle' dominant-baseline='middle'%3E%26%23128230;%3C/text%3E%3C/svg%3E">
    <link rel="manifest" href="data:application/manifest+json,{
        &quot;name&quot;: &quot;Model Converter (FBX to GLB)&quot;,
        &quot;short_name&quot;: &quot;ModelConv&quot;,
        &quot;start_url&quot;: &quot;.&quot;,
        &quot;display&quot;: &quot;standalone&quot;,
        &quot;background_color&quot;: &quot;#2c3e50&quot;,
        &quot;theme_color&quot;: &quot;#34495e&quot;,
        &quot;description&quot;: &quot;A tool to convert FBX model ZIP files into a single GLB file.&quot;,
        &quot;icons&quot;: [{
            &quot;src&quot;: &quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' rx='100' fill='%232c3e50'/%3E%3Ctext x='50%25' y='55%25' font-size='300' fill='%23ffffff' text-anchor='middle' dominant-baseline='middle'%3E%26%23128230;%3C/text%3E%3C/svg%3E&quot;,
            &quot;sizes&quot;: &quot;512x512&quot;,
            &quot;type&quot;: &quot;image/svg+xml&quot;
        }]
    }">

    <style>
        :root {
            --bg-color: #2c3e50;
            --card-color: #34495e;
            --text-color: #ecf0f1;
            --accent-color: #3498db;
            --accent-hover: #2980b9;
            --success-color: #2ecc71;
            --error-color: #e74c3c;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .container {
            width: 90%;
            max-width: 400px;
            background-color: var(--card-color);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        h1 {
            margin-top: 0;
            font-size: 1.8em;
            color: var(--text-color);
        }
        p {
            color: #bdc3c7;
            font-size: 0.9em;
            margin-bottom: 25px;
        }
        .file-input-label {
            display: block;
            padding: 15px;
            background-color: var(--accent-color);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 15px;
        }
        .file-input-label:hover {
            background-color: var(--accent-hover);
        }
        .file-input input[type="file"] {
            display: none;
        }
        .file-name {
            color: var(--text-color);
            font-style: italic;
            word-break: break-all;
            min-height: 20px;
        }
        #convertBtn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 8px;
            background-color: var(--success-color);
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            margin-top: 10px;
        }
        #convertBtn:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }
        #convertBtn:not(:disabled):active {
            transform: scale(0.98);
        }
        #status {
            margin-top: 20px;
            font-weight: bold;
            min-height: 20px;
        }
        .status-error {
            color: var(--error-color);
        }
        #downloadArea a {
            display: inline-block;
            margin-top: 20px;
            padding: 12px 25px;
            background-color: var(--success-color);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        #downloadArea a:hover {
             background-color: #27ae60;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>ðŸ“¦ Model Converter</h1>
        <p>Select a .zip file containing your .fbx model and its textures to convert it into a .glb file.</p>

        <label for="zipInput" class="file-input-label">Select Model ZIP</label>
        <input type="file" id="zipInput" accept=".zip" class="file-input">
        <div id="zipFileName" class="file-name"></div>
        
        <button id="convertBtn" disabled>Convert to GLB</button>
        
        <div id="status"></div>
        <div id="downloadArea"></div>
    </div>

    <!-- ES Module Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/",
            "fflate": "https://cdn.jsdelivr.net/npm/fflate@0.8.2/esm/browser.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
        import * as fflate from 'fflate';

        // --- DOM Elements ---
        const zipInput = document.getElementById('zipInput');
        const zipFileName = document.getElementById('zipFileName');
        const convertBtn = document.getElementById('convertBtn');
        const statusEl = document.getElementById('status');
        const downloadArea = document.getElementById('downloadArea');

        let zipFile = null;
        let objectURLs = [];

        // --- Event Listeners ---
        zipInput.addEventListener('change', (e) => {
            zipFile = e.target.files[0];
            zipFileName.textContent = zipFile ? zipFile.name : '';
            convertBtn.disabled = !zipFile;
        });

        convertBtn.addEventListener('click', handleConversion);

        function setStatus(message, isError = false) {
            statusEl.textContent = message;
            statusEl.className = isError ? 'status-error' : '';
        }
        
        // --- Core Logic ---
        async function handleConversion() {
            if (!zipFile) {
                setStatus('Please select a ZIP file.', true);
                return;
            }

            cleanup();
            setStatus('ðŸš€ Starting process...');
            convertBtn.disabled = true;

            try {
                setStatus('1/4: Processing ZIP file...');
                const { fbxData, textureFiles, modelName } = await processZip(zipFile);

                setStatus('2/4: Loading model & textures...');
                const [fbxModel, textureMap] = await Promise.all([
                    loadFBX(fbxData),
                    loadTextures(textureFiles)
                ]);
                
                applyTextures(fbxModel, textureMap);

                setStatus('3/4: Preparing model for export...');
                sanitizeModel(fbxModel);

                setStatus('4/4: Exporting to GLB...');
                const glbData = await exportGLB(fbxModel);

                createDownloadLink(glbData, modelName);
                setStatus('âœ… Success! Your GLB is ready.', false);

            } catch (error) {
                console.error('An error occurred:', error);
                setStatus(`Error: ${error.message}. Check console for details.`, true);
            } finally {
                convertBtn.disabled = false;
            }
        }
        
        function processZip(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const decompressed = fflate.unzipSync(new Uint8Array(e.target.result));
                        let fbxData = null;
                        let modelName = 'converted_model';
                        const textureFiles = {};
                        const imageExtensions = ['.png', '.jpg', '.jpeg', '.webp', '.tga'];

                        for (const path in decompressed) {
                            const lowercasePath = path.toLowerCase();
                            // Skip directories and metadata files
                            if (path.endsWith('/') || path.startsWith('__')) continue;

                            const data = decompressed[path];
                            const filename = path.split('/').pop();

                            if (lowercasePath.endsWith('.fbx') && !fbxData) {
                                fbxData = data.buffer;
                                modelName = filename.split('.').slice(0, -1).join('.');
                            } else if (imageExtensions.some(ext => lowercasePath.endsWith(ext))) {
                                textureFiles[filename] = data;
                            }
                        }

                        if (!fbxData) return reject(new Error('No .fbx file found in the ZIP archive.'));
                        if (Object.keys(textureFiles).length === 0) console.warn("No texture files found in ZIP.");

                        resolve({ fbxData, textureFiles, modelName });
                    } catch (err) {
                        reject(new Error('Failed to unzip file. It may be corrupt.'));
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read ZIP file.'));
                reader.readAsArrayBuffer(file);
            });
        }
        
        async function loadTextures(textureFiles) {
            const textureLoader = new THREE.TextureLoader();
            const textureMap = new Map();
            const promises = [];

            for (const filename in textureFiles) {
                const data = textureFiles[filename];
                const blob = new Blob([data]);
                const url = URL.createObjectURL(blob);
                objectURLs.push(url);

                promises.push(new Promise((resolve, reject) => {
                    textureLoader.load(url, (texture) => {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.flipY = true;
                        texture.encoding = THREE.sRGBEncoding;
                        textureMap.set(filename.toLowerCase(), texture);
                        resolve();
                    }, undefined, () => reject(new Error(`Failed to load texture: ${filename}`)));
                }));
            }
            await Promise.all(promises);
            return textureMap;
        }

        function loadFBX(data) {
            return new Promise((resolve, reject) => {
                try {
                    const loader = new FBXLoader();
                    const scene = loader.parse(data, '');
                    resolve(scene);
                } catch (err) {
                    reject(new Error('Failed to parse FBX file. It may be corrupt or an unsupported version.'));
                }
            });
        }
        
        function applyTextures(model, textureMap) {
            model.traverse((child) => {
                if (child.isMesh) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(material => {
                        if (material && material.name) {
                            const matName = material.name.toLowerCase();
                            for (const [texName, texture] of textureMap.entries()) {
                                if (texName.startsWith(matName)) {
                                     if (texName.includes('color') || texName.includes('diffuse') || texName.includes('albedo')) { material.map = texture; }
                                     else if (texName.includes('metal')) { material.metalnessMap = texture; }
                                     else if (texName.includes('rough')) { material.roughnessMap = texture; }
                                     else if (texName.includes('normal')) { material.normalMap = texture; }
                                     else if (texName.includes('ao') || texName.includes('ambient')) { material.aoMap = texture; }
                                }
                            }
                            material.needsUpdate = true;
                        }
                    });
                }
            });
        }

        function sanitizeModel(model) {
            model.traverse((child) => {
                if (child.isMesh) {
                    if (!child.material) {
                        child.material = new THREE.MeshStandardMaterial({ color: 0x808080 });
                        return;
                    }
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    const sanitizedMaterials = materials.map(oldMaterial => {
                        if (oldMaterial.isMeshStandardMaterial) return oldMaterial;
                        const newMaterial = new THREE.MeshStandardMaterial({ name: oldMaterial.name });
                        if (oldMaterial.color) newMaterial.color.copy(oldMaterial.color);
                        if (oldMaterial.map) newMaterial.map = oldMaterial.map;
                        if (oldMaterial.normalMap) newMaterial.normalMap = oldMaterial.normalMap;
                        if (oldMaterial.aoMap) newMaterial.aoMap = oldMaterial.aoMap;
                        if (oldMaterial.metalnessMap) newMaterial.metalnessMap = oldMaterial.metalnessMap;
                        if (oldMaterial.roughnessMap) newMaterial.roughnessMap = oldMaterial.roughnessMap;
                        newMaterial.metalness = 1.0;
                        newMaterial.roughness = 1.0;
                        newMaterial.needsUpdate = true;
                        return newMaterial;
                    });
                    child.material = Array.isArray(child.material) ? sanitizedMaterials : sanitizedMaterials[0];
                }
            });
        }

        function exportGLB(model) {
            return new Promise((resolve, reject) => {
                const exporter = new GLTFExporter();
                exporter.parse(model, (result) => resolve(result),
                    (error) => {
                        console.error("GLTFExporter Error:", error);
                        reject(new Error('Failed to export GLB. Model may have unsupported features.'));
                    }, { binary: true, animations: model.animations }
                );
            });
        }

        function createDownloadLink(glbData, modelName) {
            const blob = new Blob([glbData], { type: 'model/gltf-binary' });
            const url = URL.createObjectURL(blob);
            objectURLs.push(url);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${modelName}.glb`;
            a.textContent = 'Download GLB';
            downloadArea.appendChild(a);
        }

        function cleanup() {
            objectURLs.forEach(url => URL.revokeObjectURL(url));
            objectURLs = [];
            downloadArea.innerHTML = '';
        }

        // --- PWA Service Worker ---
        if ('serviceWorker' in navigator) {
            const swCode = `
                const CACHE_NAME = 'model-converter-cache-v2';
                self.addEventListener('install', e => e.waitUntil(caches.open(CACHE_NAME).then(c => c.add('/'))));
                self.addEventListener('fetch', e => e.respondWith(caches.match(e.request).then(r => r || fetch(e.request))));
            `;
            const swBlob = new Blob([swCode], {type: 'application/javascript'});
            const swUrl = URL.createObjectURL(swBlob);
            navigator.serviceWorker.register(swUrl).then(() => console.log('Service Worker Registered'));
        }
    </script>
</body>
</html>
